# WebSocket

실시간 양방향 통신을 위한 WebSocket 기술을 흡족하게 사용하면서 2가지 문제를 직면했습니다.
1. WebSocket 미지원 웹 브라우저: 과거 브라우저를 많이 사용하는 보험 환경 이슈(구 익스플로러)-> Socket.io, sockJS
2. 웹 브라우져가 아닌 클라이언트 -> STOMP

## 정의
* 표준 WebSocket의 API는 W3C에서 관장하고, 프로토콜은 IETF에서 관장
* WebSocket은 HTTP(S)를 사용하여 연결요청, UTF-8 및 이진 메시지를 모두 지원하는 웹을 통해 클라이언트와 서버 간의 빠르고 안전한 양방향 통신을 위한 메커니즘
  - HTTP 통신으로 80 or 443포트로 통신
  - 과정을 handshake라고 하며, http를 Websocket 프로토콜로 바꾸는 Protocol switching
  - 단일 소켓 연결으로, 실시간으로 두 엔드포인트에서 데이터를 주고 받을 수 있음
  - 서버와 클라이언트의 양방향 통신이 가능
  - 상태를 유지하는 프롤토콜(Stateful protocol)으로 서버와 클라이언트 간에 Socket Connection을 유지해 언제든 통신 및 데이터 전송 가능

## 오버헤드 비교
폴링(Polling) 방식:
요청/응답 헤더 데이터 용량: (871 Byte)

1. 1000명 *  헤더 데이터 용량  = 871,000  Byte
2. 10000명 *  헤더 데이터 용량  = 8,710,000  Byte
3. 100000명 *  헤더 데이터 용량  = 87,100,000 Byte

WebSocket 방식:
메시지 데이터 용량: (2 Byte)
1. 1000명 *   메시지 데이터 용량   = 2,000  Byte
2. 10000명 *   메시지 데이터 용량   = 20,000  Byte
3. 100000명 *   메시지 데이터 용량   = 200,000 Byte

출처: https://mohwaproject.tistory.com/entry/ㅁㅁㅁ


## 연결 설정
서버와 클라이언트 간의 WebSocket 연결은 HTTP 기반 핸드쉐이크가 필요
* 클라이언트 요청
  ```http
  GET /chat HTTP/1.1
  Host: server.example.com
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
  Sec-WebSocket-Protocol: chat, superchat
  Sec-WebSocket-Version: 13
  Origin: http://example.com
  ```
  - 요청 시 HTTP 헤더에 Upgrade 속성과, WebSocket 보안 키를 전송
* 서버 응답
  ```http
  HTTP/1.1 101 Switching Protocols
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
  Sec-WebSocket-Protocol: chat
  ```
  - Switching Protocols 상태인 101과 요성한 WebSocket 보안 키를 응답
  - 통신이 서로 성공하면 애플리케이션 계층 프로토콜이 이전에 설정된 TCP 연결을 사용하여 HTTP에서 WebSocket으로 **업그레이드**

---

> 주로 실시간이 요구되는 Real-time web application구현을 위해 사용하는 기술로서 실시간이 요구되는 프로덕션 환경에 주로 적용하여 구현했습니다.
> - 타사와 제휴한 자동차 및 중고차 시승보험 영업 서비스
> - 인천공항 주차장비 및 키오스크 장비 실시간 장애 체크 및 장비제어
>
> 코로나 이슈로 비대면 영업이 활성화 되면서, 실시간으로 전화 영업으로 인한 자동차 보험 가입 상태를 파악해 자동차 딜러에게 안내해 주는 서비스와 인천공항의 모든 주 장비의 상태를 실시간으로 확인이 가능하며, 장애 발생시 즉각 대응 알림 및 주차장비를 관제 및 제어하는 양방향 서비스를 개발하였습니다.
> 실시간이 필요한 서비스에는 WebSocket을 이용하여 응용 어플리케이션을 개발하는데 큰 도움이 된다고 생각합니다.

# Socket.io
## 정의
* node.js 기반으로 만들어진 기술 스팩
* Socket.io는 JavaScript를 이용하여 실시간 웹을 구현할 수 있도록 한 기술
* WebSocket, FlashSocket, AJAX, IFrame, JSONP Polling등 다양한 통신을 하나의 API로 추상화
  - 즉 브라우저 종류에 상관없이 실시간 웹 서비스를 구현 가능
  - 개발자가 각 기술을 깊이 이해하지 못하거나 구현 방법을 잘 알지 못해도 사용

---

> WebSocket 미지원 웹 브라우져에서 실시간 서비스를 위해 이 기술을 사용했습니다.
> - 구버전 익스플로러 환경에서 자동차 보험 서비스 환경
>
> 타사의 자동차 보험 서비스 서버와 인터페이스 하는 Node.js 기반 socket.io 중계서버를 만들고, 구 버전 익스플로러 환경일 경우 socket.io 클라이언트 객체를 통해 서버와 연결 세션을 가지는 환경을 개발 했습니다.
> Socket.io기술을 이용해 WebSocket이 지원되지 않는 환경에서도 이벤트 기반으로 실시간 서비스를 개발 가능합니다.

# STOMP
## 정의
* Simple (or Streaming) Text Oriented Message Protocol 의 약자인 STOMP는 텍스트 기반의 메세징 프로토콜
* STOMP 사용 환경은 TCP 나 WebSocket 과 같은 신뢰성있는 양방향 streaming network protocol 상에 사용
* HTTP에 모델링된 frame 기반 프로토콜
* STOMP는 구독이라는 개념을 통해 내가 통신하고자 하는 topic을 판단하여, 브로커라는 개념으로 실시간, 지속적으로 관심을 가지며 요청을 처리

> 실시간으로 주차 장비를 관제하는 WebSocket 서버로, 주차 장비 및 다양한 클라이언트들과 통신할 수 있는 서버를 구성하는 것이 목표였습니다.
클라이언트 구성은 .Net 기반 주차장비와, JavaFx 키오스크, 모바일(Android, iOS)과 웹 브라우저 입니다.
이 프로젝트에서 이슈는 2가지를 해결해야 했습니다.
>  1. WebSocket을 지원하지 않는 브라우저
>  2. 웹 브라우저 이외의 클라이언트
>
> 이 2가지 문제를 해결하기 위해 Spring Framework 기반 STOMP + sockJS 구성 서버를 개발했습니다.
> 1. WebSocket을 지원하지 않는 브라우져에서는 sockJS를 이용해서 서버 실시간으로 통신
> 2. 웹 브라우저 이외의 클라이언트는 STOMP 규격으로 서버와 실시간 통신
>
> 이렇게 하나의 서버로 STOMP와 sockJS + STOMP 두개를 오픈하고 각각의 경로로 들어온 message에 대해서 동일한 소스로 처리하여, 모두 다른 클라이언트 환경에서 동일한 서비스를 제공하는 결과를 만들었습니다.
>
> 프로젝트를 진행하면서, 실시간 양방향 통신에 대한 이슈 관리와 유연한 서버 모듈을 개발하는 데 큰 도움이 됬습니다.


# sockJS
## 정의
* SockJS는 Socket.io와 유사한 라이브러리로 websocket을 지원하지 않는 브라우저를 위한 라이브러리
* springframework에서 WebSocket을 지원
  + 스프링 메뉴얼에는 WebSocket 브라우저 미지원 문제 해결을 위해 SockJS 사용을 추천하여 도입
  + 스프링 서버 개발시 설정을 통해 WebSocket 통신 또는 sockJS 호환으로 통신할지 결정 가능
  + 클라이언트는 sockJS Client를 통해 서버와 실시간 통신

> WebSocket 미지원 웹 브라우져에서 실시간 서비스를 위해 이 기술을 사용했습니다.
> Socket.io와 비슷한 라이브러리지만, Socket.io 라이브러리를 사용하기 위해서는 Node.js 기반  Socket.io 서버를 구현해야는 이슈가 있습니다.
>
> 하지만, 한개의 주차 관제 WebSocket 서버에서 모든 클라이언트를 관제하기 위해 SockJS를 사용했습니다.
> 현장 특성상 구버전 익스플로러를 많이 사용하는 환경으로, 브라우저 버전을 확인 후, WebSocket 미지원 브라우저일 경우, sockJS Clinet로 Spring 서버와 실시간 통신 기능을 개발했습니다.


# STOMP WebSocket 보안
실시간으로 주차 장비를 관제하는 STOMP 기반 WebSocket 서버의  WebSocket 보안 기능 개발

## 정의
* Spring Security를 통한 로그인 인증
* JWT(Json Web Token)을 이용한 WebSocket통신 보안 기능 강화

> 1. Spring Security 설정을 통해 로그인 인증과 권한을 부여
>
> 로그인 이후에는 WebSocket기반 으로 통신을 하는데, 헤더에 토큰을 검사하는 HTTP 프로토콜과는 다르기 떄문에 이슈가 발생했습니다.
>
>> 최초 핸드쉐이킹 과정에서 HTTP -> WS Upgrade 과정에 HTTP 메세지에 인증 헤더를 추가하는 방안을 고려했지만, WebSocket 연결 후 별도 서비스의 권한 제어가 불가능 했습니다.
>
> 그리하여, WebSocket 연결 및 메세지 전송시에 JWT 토큰을 관리하여 통제하는 방안을 도입했습니다.
>
> STOMP 라이브러리를 이용한 WebSocket 통신 시 hearder에 Jwt를 설정하여 검증 된 Token 유무를 판단해, 검증된 클라이언트만 서비스 하도록 설정했습니다.
>>  StompHandler빈을 만들어 인터셉터에 설정함으로서, WebSocket을 통한 실시간 통신에서도 인증 서비스 제공
>


# Spring @AOP
## 정의
* AOP는 애플리케이션 전체에 걸쳐 사용되는 공통된 기능을 재사용하는 기법
* Spring AOP는 프록시 패턴이라는 디자인 패턴을 사용해서 AOP 효과
* 특정 빈이 AOP에 해당되는 빈이라면, 빈으로 등록될 때, Spring AOP로 인해 자동으로 프록시 빈으로 등록
* AOP 주요 구현 개념
  - Aspect: AOP 적용이 되는 Target 대상
  - Advice: 실질적으로 기능 구현체 -> 기능 구현에만 집중
  - PointCut: 부가기능이 적용될 대상을 선정하는 방법

> Spring 의 주요개념 LoC, AOP, PSA 중 하나로 흩어진 공통 기능을 모듈화 하는  객체지향적 프로그래밍 기법입니다.
> Spring에서 대표적으로 @Transaction 처리가 AOP를 이용한 기능입니다.
>
> * 클래스, 메소드에 @Transactional이 선언되면 해당 클래스에 트랜잭션이 적용된 프록시 빈 생성
> * 프록시 빈 객체는 @Transactional이 포함된 메서드가 호출될 경우, Auto Commit false 후, 트랜잭션을 시작하고 Commit or Rollback을 수행
> * CheckedException or 예외가 없을 때는 Commit
> * UncheckedException이 발생하면 Rollback
>
> 카플래너 프로젝트 중 Spring AOP를 이용하여 결제 관련 모듈을 개발했습니다.
> 어노테이션 기반으로 런타임 환경에서 프록시 빈을 생성하여 AOP기능을 구현했습니다.
> @Around 와 @AfterThrowing 어드바이스를 이용하여 결제 전후 관련 로깅, 결제 실패 추적 및 장애 추적, @Mock테스트를 위한 테이크 결제 기능을 구현했습니다.

# Jenkins
## 정의
* 젠킨스는 소프트웨어 개발 시 지속적으로 통합 서비스를 제공하는 CI(Continuous Integration) 툴
* 프로젝트 표준 컴파일 환경에서의 컴파일 오류 검출 기능
* 자동화 테스트 수행
* 정적 코드 분석에 의한 코딩 규약 준수여부 체크
* 프로파일링 툴을 이용한 소스 변경에 따른 성능 변화 감시
* 결합 테스트 환경에 대한 배포작업

> 카플래너 프로젝트 중 제휴 서비스로 인해 개편 이슈로 다양한 기능이 추가 되면서 배포 주기가 짧아지면서 이슈가 발생하여 Jenkins를 도입했습니다.
> 리눅스 서버 환경에 Git과 연동하여 Jenkins를 도입하여, 무중단 배포 환경울 구성했습니다.
> 무중단 배포 뿐만 아니라, 컴파일 환경에서 오류를 검출하고, 빌드 단위 테스트를 수행함으로서, 배포 전 장애를 방지하는 확인을 한번더 할 수 있었습니다.


# MSA
## 정의
* MSA 마이크로서비스 아키텍처는 소프트웨어 개발 기법 중 하나
* 애플리케이션을 상호 독립적인 최소 구성 요소로 분할하여 구성
* 모든 요소를 하나의 애플리케이션에 구축하는 전통적인 모놀리식 접근 방식 대신 마이크로서비스에서는 모든 요소가 독립적이며 연동 구조
* 다수의 애플리케이션 간에 유사한 프로세스를 공유(엔터프라이즈 통합)하는 기능
* 각 컴포넌트는 작은 책임 영역을 담당하고 완전히 상호 독립적으로 배포
* 애플리케이션은 항상 기술 중립적 프로토콜을 사용해 통신하므로 서비스 구현 기술과는 무관하다. 따라서 마이크로서비스 기반의 애플리케이션을 다양한 언어와 기술로 구축할 수 있다는 것을 의미
* 작고 독립적이며 분산된 마이크로서비스를 사용해 조직은 명확히 정의된 책임 영역을 담당하는 소규모 팀을 보유할 수 있다. 이 팀들은 애플리케이션 출시처럼 하나의 목표를 향해 일하지만, 자기가 개발하는 서비스만 책임

> 인천공항 프로젝트에서 MSA 환경 기반으로 독립적으로 진행했습니다.
>
> 차량과 관련된 모든 서비스를 관제하는 프로젝트로, 인천공항 제 1터미널, 2터미널 이용객 주차 서비스 및 키오스크, 버스, 영업차량 및 VIP, 택시 등 모든것을 관제하는 서비스를 MSA 기반으로 개발하였습니다.
> 제가 담당했던 프로그램은, 키오스크와 택시 관제 서비스로
> * 키오스크: 키오스는 주차 관제 서버로 부터 주차 정보를 조회하여 주차 유도 및 주차 정산 서비스
> * 택시관제: 인천공항에 모든 택시 차량을 관리하여, 손님과 매칭시켜주는 서비스
>
> 독립적인 서비스를 분할하여 복잡도가 감소하고 효율적인 인원분배로 효과적으로 개발할 수 있었습니다.

> 리치앤코 카플래너 프로젝트도 MSA 환경으로 개발되었습니다.
> 리치앤코는 모든 보험사의 보험을 중계해 좋은 상품을 추천해 주는 서비스를 합니다.
> 다양한 보험 중 저는 자동차 보험 관련 서비스를 담당 개발하였고, 유저가 보험을 요청하면 CRM 서버에 전달하여, 전화영업 or 대면영업으로 보험 상품을 소개하고 가입하는 서비스를 개발하였습니다.



# React Native
## 정의
* React Native는 리액트를 기반으로 ‘모바일 웹 앱’이나 ‘하이브리드 앱’이 아닌 ‘네이티브 앱’을 제작할 수 있는 오픈소스 프레임워크
* React Native는 리액트의 접근 방법을 모바일(Android, iOS)로 확장하는 페이스북의 오픈소스 프로젝트로

> Javascript로 Android, iOS를 모두 제어해서 개발할 수 있는 환경이며, 네이티브 앱을 제어하는 기능을 개발할 수 있습니다.
> 카플래너 프로젝트 중 리엑트 네이티브를 이용하여, 두가지 OS 환경의 모바일 웹을 제어하는 기능을 개발했습니다.
> * 결제 서비스 관련하여 Web View를 제어해야 하는 이슈
> * 모바일 네이티브 한경에서 저장환 이미지를 불러오는 기능
>
> 간단한 서비스 로직들을 자바스크립트(JavaScript)로 공통 관리하는 기능을 개발했습니다.
> 간단한 UI 외관을 구현하는 템플릿을 구현했습니다.
> **핫리로드, 라이브 리로드** 를 통해 수정 사항을 바로 확인하며 개발 할 수 있어 매우 효율적이였습니다.

# JPA
## 정의
* Java 진영의 ORM 표준 기술
* 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 **인터페이스**
* JPA는 자바 어플리케이션에서 관계형 데이터베이스를 어떻게 사용하는지 정의

> Hibernate 라는 JPA 구현체를 주로 사용하며 엔티티를 관리하는 영속성 컨텍스트로 인해 여러 장점이 있습니다.
> * 1차 캐쉬 기능
> * 동일성 보장
> * 쓰기 지연 기능
> * 지연로딩과 즉시 로딩
> * 변경감지
>
> 주차관제서버를 개발할 때 JPA를 이용해서 개발을 진행했습니다.
> 객체지향적 비즈니스 로직에 집중하여 개발했습니다.
> SQL로 직접 작성하지 않고, ORM 프레임워크가 대신 엔티티 필드가 되는 객체를 다르기 떄문에 유지보수가 간결하겨 개발했습니다.
> 복잡한 프로젝트 같은 경우에 Oracle, Mysql, Mssql 서로 같은 데이터베이스를 동시에 사용할려고 할 때, JPA 쓰게 된다면 데이터베이스와는 독립적이기 떄문에 크게 여의치 않고 쉽게 사용할 수 있다고 생각합니다. 

























# END
