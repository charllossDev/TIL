# java

# 객체지향 언어(OOP)

* 장점
  + 캡슐화
  + 상속
  + 다형성
  * JVM 위에서 동작하기 떄문에 운영체제에 독립적
  * 가비지 컬렉터(GC)가 메모리를 관리
* 단점
  + 설계의 복잡함
  + JVM 위에서 동작하기 떄문에 런타임 속도가 상대적으로 느림
  * 다중 상속이나 타입에 엄격한 제한

* JVM
* JRE
* JDK

* version
  + java8
  + java11

* 기능
  + Reflection

## 장점

1. 캡슐화
필요한 속성(attribute)과 행위(method)를 하나로 묶고 그 중 일부를 외부에서 사용하지 못하도록 은닉한다.
관련된 코드와 데이터가 묶여있고 오류가 없어 사용이 편리하다.
데이터를 감추고 외부 세계와의 상호작용은 메서드를 통하는 방법으로, 라이브러리로 만들어 업그레이드하면 쉽게 바꿀 수 있다.

2. 상속
이미 생성된 클래스를 상속받아 새로운 클래스를 생성하는 기법으로, 기존 코드의 재활용해서 사용하는 것을 의미한다.
객체지향 방법의 큰 장점

3. 다형성
하나의 이름(방법)으로 많은 상황에 대처하는 기법이다.
개념적으로 동일한 작업을 하는 함수들에게 똑같은 이름을 부여할 수 있음으로 코드의 의미가 정확해 질 수 있다.

# 자바 가상 머신(Java Virtual Machine, JVM)
* 가상머신이란, 프로그램을 실행하기 위해 물리적으로 유사한 머신을 소프트웨어로 구현한 것
* Java와 OS사이에서 중개자 역활을 하며, Java가 OS에 구애받지 않고 재사용 가능하도록 함
* 메모리관리, GC 수행
* 스택기반의 가상머신
* 클래스로더를 통해 읽어 들여 자바API와 함께 실행

1. 프로그램이 실행되면 JVM은 OS로 부터 프로그램이 필요로 하는 메모리를 할당(JVM은 메모리를 용도에 따라 여러 영역으로 나누어 관리함)
2. 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어들여 자바 바이트코드(.class)로 변환(.java -> .class)
3. Class Loader를 통해 class파일들을 JVM으로 로딩
4. 로딩된 class파일들은 Execution engine을 통해 해석
5. 해석된 바이트코드는 Runtime Data Areas에 배치되어 실질적인 수행을 함(이러한 실행과정 속에서 JVM은 필요에 따라 Thread Synchronization과 GC같은 관리 작업을 수행함)

1. JVM 사양
첫째, JVM은 소프트웨어 사양이다. 다소 순환적인 방식으로, JVM 사양은 구현에 있어 최대한의 창조성을 허용하기 위해, JVM 구현 세부사항이 사양 안에 정의되어 있지 않다고 강조하고 있다.

"자바 가상 머신을 올바르게 구현하려면, 클래스(Class) 파일 포맷을 읽고 그 안에 지정된 작업을 제대로 수행하기만 하면 된다."

요한 세바스찬 바흐도 음악을 비슷하게 창조한다고 기술했다.

"정확한 시점에 올바른 건반을 누르기만 하면 된다."

결국, JVM이 해야만 하는 일은 자바 프로그램을 정확하게 실행하는 것뿐이다. 간단해 보인다, 심지어 겉으로 보기에는 단순해 보이기도 하지만, 자바 언어의 능력과 유연성을 고려할 때, 이것은 엄청나게 힘든 일이다.

2. JVM 구현
JVM 사양 구현은 실제 소프트웨어 프로그램을 도출하며, 이것이 JVM 구현이다. 실제로, 오픈소스와 특정 업체 고유의 JVM 구현이 다수 존재한다. 오픈JDK의 핫스팟(HotSpot) JVM은 참조 구현이며, 세계에서 가장 철저하게 증명된 코드기반 중 하나로 남아있다. 핫스팟은 가장 널리 사용되는 JVM이기도 하다.

오라클의 라이선스가 부여된 JDK를 포함해, 라이선스가 부여되는 거의 모든 JVM은 오픈JDK와 핫스팟 JVM의 포크(Fork)로 생성된 것이다. 오픈JDK로부터 허가받은 포크를 생성하는 개발자들은 종종 운영체제 고유의 성능 개선사항들을 추가하려는 욕구에 의해 동기 부여된다. 일반적으로, 개발자는 JRE(Java Runtime Environment) 번들의 한 부분으로 JVM을 다운로드해 설치한다.

3. JVM 인스턴스(Instance)
JVM 스펙이 구현돼서 소프트웨어 제품으로 릴리즈되면, 개발자는 그것을 하나의 프로그램처럼 다운로드해 실행할 수 있다. 이렇게 다운로드 된 프로그램이 하나의 JVM 인스턴스(또는 인스턴스화된 버전)이다.

개발자들이 "JVM"에 대해 말하는 경우, 대부분의 경우에는 소프트웨어 개발 환경 또는 제품화 환경에서 실행되는 하나의 JVM 인스턴스를 지칭한다. "아난드, 그 서버에 있는 JVM은 메모리를 얼마나 사용하고 있어?" 또는 "순환 호출(Circular Call)을 하는 바람에 스택 오버플로우 에러가 내 JVM을 망가뜨렸다니, 믿을 수가 없군. 이런 초보적인 실수를 하다니!"라고 말할 지도 모른다.

가상 머신(Virtual Machine)으로서의 JVM
JVM은 자바 클래스 파일을 이식성 있는 방식으로 실행하는 가상 머신이다. 가상 머신이란 JVM이 하부에 있는, 실제 머신–예를 들면, 프로그램이 실행되는 서버–의 추상화(Abstraction)를 의미한다. 사용 중인 운영체제 또는 실제로 존재하는 하드웨어에 관계없이, JVM은 그 안에서 실행될 프로그램을 위한 예측 가능한 환경을 조성한다. 하지만, 진정한 가상 머신과 달리 JVM은 가상 운영체제를 생성하지 않는다. JVM을 관리되는 런타임 환경(Managed Runtime Environment) 또는 프로세스 가상 머신이라고 정의하는 것이 더 정확할 수도 있다.

소프트웨어 사양이란
소프트웨어 사양(또는 스펙)이란 어떤 소프트웨어 시스템이 어떻게 동작해야 하는 지를 정의하는 인간이 읽을 수 있는 설계 문서다. 사양의 목적은 엔지니어들이 코딩할 수 있도록 정확한 정의와 요구사항을 기술하는 것이다.

JVM에서 클래스 파일 로드와 실행
자바 애플리케이션 실행에 있어 JVM의 역할에 대해 살펴봤다. 그런데 이 기능을 실제로는 어떻게 수행할까. 자바 애플리케이션을 실행하기 위해 JVM은 자바 클래스 로더(Class Loader)와 자바 실행 엔진(Execution Engine)에 의존한다.

- JVM 자바 클래스 로더
자바에서는 모든 것이 클래스이며, 모든 자바 애플리케이션은 클래스로부터 만들어진다. 하나의 애플리케이션이 하나 또는 수천 개의 클래스로 구성될 수 있다. 자바 애플리케이션을 실행하기 위해서는, JVM이 컴파일된 .class 파일을 맥락에 따라 액세스 가능한 서버 같은 것으로 로드 해야만 한다. JVM은 클래스 로더에 의존해 이 기능을 수행한다.

자바 클래스 로더는 클래스를 메모리에 로드하고 실행을 위해 사용할 수 있게 만드는 JVM의 일부다. 클래스 로더는 클래스 로딩(Class Loading)을 최대한 효율적으로 수행하기 위해 지연 로딩(Lazy-loading)과 캐싱(Caching) 같은 기법을 활용한다. 그렇긴 하지만, 클래스 로딩이 이식성 있는 런타임 메모리 관리처럼 대단히 까다로운 것이 아니기 때문에 이런 기법들은 비교적 간단하다.

모든 자바 가상 머신에는 클래스 로더가 포함되어 있다. JVM 스펙은 런타임에 클래스 로더에 질의(Query: 쿼리)하고 조작하기 위한 일반적인 방법들을 설명하고 있지만, 이런 기능을 충족시키는 책임은 JVM 구현에 있다. 개발자의 관점에서 볼 때, 근본적인 클래스 로더 메커니즘은 대개 블랙 박스다.

- JVM 실행 엔진
클래스 로더가 클래스를 로딩하는 작업을 마치면, JVM은 각 클래스에 있는 코드를 실행하기 시작한다. 이 기능을 처리하는 것이 JVM 구성요소인 실행 엔진이다. 실행 엔진은 JVM 실행에 필수적이다. 실제로, 현실적인 목적을 위해, 실행 엔진은 JVM 인스턴스다.

코드 실행에는 시스템 리소스에 대한 액세스 관리가 관련되어 있다. JVM 실행 엔진은–파일, 네트워크 그리고 메모리 리소스를 요구하는–프로그램 실행과 운영체제 가운데 위치해서 이런 리소스들을 공급한다.

- 실행 엔진이 시스템 리소스를 관리하는 방법
시스템 리소스는 크게 메모리와 다른 모든 것, 2가지 범주로 나눌 수 있다.

JVM이 미사용 메모리를 없애야 할 책임이 있으며, 가비지 컬렉션이 이런 폐기를 수행하는 메커니즘이라는 것을 상기하라. JVM은 개발자들이 당연하게 여기고 있는 참조 구조체(Referential Structure)를 할당하고 관리할 책임도 있다. 예를 들어, JVM의 실행 엔진은 자바의 new 키워드 같은 것을 받아, 그것을 메모리 할당에 대한 운영체제 고유의 요청으로 변환할 책임이 있다.

메모리를 넘어서, 실행 엔진은 파일 시스템 액세스, 네트워크 입출력을 위한 리소스를 관리한다. JVM이 여러 운영체제 전반에서 호환되기 때문에, 실행 엔진은 각각의 운영 체제 환경에 즉각 대응할 수 있어야만 한다. 이것이 JVM이 종잡을 수 없는 요구사항을 처리하는 방법이다.

JVM의 과거, 현재, 미래
1995년, JVM은 이후 최신 소프트웨어 개발에 대한 기준이 된 2가지 혁신적인 개념을 소개했다. "한 번 작성해, 모든 곳에서 실행", 그리고 자동 메모리 관리였다. 당시에는 소프트웨어 상호운영성이 대담한 개념이었지만, 지금은 소수의 개발자들만이 재고할 뿐이다. 마찬가지로, 우리 엔지니어 선배들이 프로그램 메모리를 스스로 관리했던 것처럼, 우리 세대는 가비지 컬렉션과 함께 성장했다.

현대 프로그래밍을 발명한 사람은 제임스 고슬링과 브렌단 아이크지만, 수천 명의 다른 사람들이 다음 수십 년 동안 그들의 생각을 다듬고 쌓아왔다. 처음에는 자바만을 위한 자바 가상 머신이었지만, 이제는 진화해 스칼라(Scalar), 그루비(Groovy), 그리고 코틀린(Kotlin)을 포함한 수 많은 스크립팅 언어와 프로그래밍 언어를 지원하고 있다. 앞으로, JVM이 개발 환경의 중요한 부분이 아닌 미래를 보는 것은 어렵다.

# 자바 개발환경(Java Runtime Environment, JRE)
JRE는 JVM이 자바 프로그램을 동작시킬 때 필요한 라이브러리 파일들과 기타 파일을 가지고 있다.
JRE는 자바 코드를 실행하기 위한 도구들로 구성된 패키지라는 점이다.

# 자바 개발도구(Java Development kit, JDK)
JDK는 JRE + 개발을 위해 필요한 도구(javac, java등)들을 포함한다.
JDK는 컴파일러와 클래스 라이브러리(Class Library)를 포함하는, 자바 플랫폼 사양서의 구현이다.

# 기능

## Reflection
리플렉션은 구체적인 클래스 타입을 알지 못해도, 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API

자바의 Reflection은 JVM에서 실행되는 어플리케이션의 런타임 동작을 검사하거나 수정할 수 있는 기능이 필요한 프로그램에서 사용한다.

> 쉽게 말하자면, 클래스의 구조를 개발자가 확인할 수 있고, 값을 가져오거나 메소드를 호출하는데 사용

Reflection을 사용하는 기술을은 주로 ORM 기술인 하이버네이트가 있다.

Reflection을 사용해 스프링에서는 런타임 시에 개발자가 등록한 빈을 어플리케이션에서 가져와 사용할 수 있게 된다.

### Why?
자바는 정적인 언어라 부족한 부분이 많은데 이 동적인 문제를 해결하기 위해서 리플렉션을 사용

#### 정적 언어, 동적 언어 ?
* 정적 언어: 컴파일 시점에 타입을 결정 ex) Java, C, C++ 등..
* 동적 언어: 런타임 시점에 타입을 결정 ex) Javascript, Python, Ruby 등..

리플렉션은 애플리케이션 개발에서보다는 프레임워크, 라이브러리에서 많이 사용됩니다.
프레임워크, 라이브러리는 사용하는 사람이 어떤 클래스를 만들지 모릅니다. 이럴 때 동적으로 해결해주기 위해서 리플렉션을 사용합니다.
대표적인 사용 예로는 스프링의 DI(dpendency injection), Proxy, ModelMapper 등이 있습니다.

### 코드로 예를 볼까요?

```java

@Controller
@RequestMapping("/articles")
public class ArticleController {    

    @Autowired    
    private ArticleService articleService;       
       ....

    @PostMapping
    public String write(UserSession userSession, ArticleDto.Request articleDto){
       ...
    }

    @GetMapping("/{id}")
    public String show(@PathVariable int id, Model model) {
       ...
    }
}
```

스프링을 사용할 때 @Controller 를 넣어주면 인스턴스를 생성 하지 않아도 스프링이 알아서 생성해서 빈으로 관리해줍니다.

* 스프링은 ArticleController의 존재를 어떻게 알고 만들어주는 것일까요?
* ArticleService 라는 필드는 어떻게 주입해주는 걸까요?
* 모든 메소드의 파라미터 개수, 타입이 다른데 어떻게 알고 해당하는 값을 바인딩 해줄까요?

ArticleController을 작성한 개발자는 클래스의 정보를 알겠지만, 스프링은 모릅니다.
이 문제를 해결하기 위해서 리플렉션을 사용합니다. (스프링이 ArticleController의 정보를 알아내기 위해서)

대략 흐름을 보자면

* @Controller 를 갖고있는 클래스를 스캔
* 해당하는 클래스의 인스턴스 생성 및 필드 DI


### 특징
* 확장성 특징 : 애플리케이션은 정규화된 이름을 사용하여 확장성 객체의 인스턴스를 생성하여 외부 사용자 정의 클래스를 사용할 수 있습니다.
* 클래스 브라우저 및 시각적 개발 환경을 제공합니다 : 클래스 브라우저는 클래스의 Method, Property, Constructor를 열거할 수 있어야 합니다. 시각적 개발 환경은 개발자가 올바른 코드를 작성하는데 도움이 되도록 Reflection에서 사용할 수 있는 형식 정보를 사용하면 도움이 됩니다.
* 디버거 및 테스트 도구입니다 : 디버거는 개인 Property, Method, Constructor를 검사할 수 있어야 합니다. 테스트 장치는 Reflection을 사용하여 클래스에 정의된 발견 가능한 세트 API를 체계적으로 호출하여 테스트에서 높은 수준의 코드 커버리지를 보장합니다.

### 단점
Reflection은 강력한 도구이지만, 무분별하게 사용해서는 안됩니다. Reflection을 사용하지 않고 수행 가능하다면, 사용하지 않는 것이 좋습니다. Reflection을 통해 코드에 접근할 때는 다음 사항을 염두에 두어야 합니다.
* Performance의 오버헤드 : Reflection에는 동적으로 해석되는 유형이 포함되므로, 특정 JVM 최적화를 수행할 수 없습니다. 따라서 Reflection 작업이 비 Reflection 작업보다 성능이 떨어지며, 성능에 민감한 애플리케이션에서 자주 호출되는 코드엔 사용하지 않아야 합니다.
* 보안 제한 사항 : Reflection에는, 시큐리티 매니저의 실행 시에 존재하지 않는 실행 시 액세스 권한이 필요합니다. 이것은 애플릿과 같이 제한된 보안 컨텍스트에서 실행되어야 하는 코드에 대한 중요한 고려 사항입니다.
* 캡슐화를 저해할 수 있습니다 : Reflection은 private한 Property및 Method에 액세스하는 것과 같이 비 Reflection 코드에서 작동하지 않는 코드를 수행할 수 있으므로, Reflection을 사용하면 예기치 않은 부작용이 발생하여 코드 기능이 저하되고 이식성이 손상될 수 있습니다. 또한 Reflection은 추상화를 깨뜨려 플랫폼 업그레이드 시 동작이 변경될 수 있습니다.








































## Test
