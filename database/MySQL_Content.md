# 1.DBMS

데이터베이스 관리 시스템(영어: database management system, DBMS)은 다수의 사용자들이 데이터베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어 도구의 집합이다.

* 데이터를 CRUD(생성, 수정, 삭제, 검색)하는 시스템
* 검색에 최적화(인덱스)
* **업데이트가 많은 경우 대안이 필요**

## Index

인덱스의 종류

* 이진검색(Binary Search)
    + 최대 log2(N)번 내에 검색가능
* B-Tree 계열
    + 최대 log3(n)번 내에 검색가능
    + 상용 DBMS에서 가장 많이 사용

> 데이터 추가/수정/삭제할 때마다 정렬/인덱스 업데이트가 일어남


### Binary Search

이진 검색 알고리즘(binary search algorithm)은 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘이다. 처음 중간의 값을 임의의 값으로 선택하여, 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식을 채택하고 있다. 처음 선택한 중앙값이 만약 찾는 값보다 크면 그 값은 새로운 최댓값이 되며, 작으면 그 값은 새로운 최솟값이 된다. 검색 원리상 정렬된 리스트에만 사용할 수 있다는 단점이 있지만, 검색이 반복될 때마다 목표값을 찾을 확률은 두 배가 되므로 속도가 빠르다는 장점이 있다.

이진탐색으로 전체에서 중간값을 탐색
그 결과로 나눠진 2개의 중간값을 탐색 -> 계속반복
+

* **데이터가 추가/삭제/변경 될 때마다 한가운데, 왼쪽 가운데/ 오른쪽 가운데값 등을 미리 계산해 놓음**

> 인덱스(Index) 라고 통칭 함

### B-Tree

전산학에서 B-트리(B-tree)는 데이터베이스와 파일 시스템에서 널리 사용되는 트리 자료구조의 일종으로, 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다.

방대한 양의 저장된 자료를 검색해야 하는 경우 검색어와 자료를 일일이 비교하는 방식은 비효율적이다. B-트리는 자료를 정렬된 상태로 보관하고, 삽입 및 삭제를 대수 시간으로 할 수 있다. 대부분의 이진 트리는 항목이 삽입될 때 하향식으로 구성되는 데 반해, B-트리는 일반적으로 상향식으로 구성된다.

이진 탐색과 유사하지만, 한 번에 비교를 2번(a , b : a < b)하여, 즉 경우의 수는 3가지

* 작은 값 보다 작은경우
* 큰 값과 작은 값 사이인 경우
* 큰 값보다 큰 경우

그렇기 때문에 이진탐색보다 속도가 빠르다 (이진탐색 < B-트리 탐색)

* **데이터가 추가/삭제/변경 될 때마다 a, b 값을 업데이트**

## DBMS 종류

* 계층형 데이터베이스
* 네트워크 데이터베이스
* **관계형 데이터베이스**(RDBMS)
* 객체지향 데이터베이스
* 객체관계형 데이터베이스(ORDBMS)
* NoSQL(Not Only SQL)



# 2. RDBMS

관계형 데이터베이스 관리 시스템(Relational Database Management System, RDBMS)은 IBM 산호세 연구소의 에드거 F. 커드가 도입한 관계형 모델을 기반으로 하는 데이터베이스 관리 시스템이다. 현재 사용되는 대부분의 데이터베이스는 관계형 데이터베이스 모델을 기반으로 한다.

1980년대 이래로 RDBMS는 재무기록, 제조 및 물류 정보, 인사 데이터 등의 정보를 저장하는데 가장 많이 사용되는 스토리지다. 과거 계층형 데이터베이스나 네트워크 데이터베이스에 비해 사용 및 이해가 쉬워 관계형 데이터베이스가 이들을 많이 대체했다. 하지만 요즘은 XML 데이터베이스나 객체지향적 모델과 관계형 모델의 불일치 문제를 해결하기 위해 대두된 객체 지향 데이터베이스와 같은 새로운 경쟁자들이 대두되고 있다.

* 테이블 기반의 DBMS
    + [x] 테이블 - 컬럼 형태의 데이터 저장 방식
    + [x] 테이블과 테이블 간의 연관관계(주로 외래키형태)를 이용해 필요한 정보를 구하는 방식
    + 하나의 테이블은 여러 개의 컬럼으로 구성
    + 테이블끼리의 중복정보는 최소화 시킴
        - 동일한 데이터가 여러군데 중복되어 존재하면 데이터의 수정시 문제 발생 확률 높아짐
        - 정규화(Nomalize) - > 정규형
        - 여러 테이블을 합쳐 큰 테이블을 생성(JOIN)
* 모델링은 E-R(Entity Relationship) 모델을 사용
* 테이블을 엔티티(기본)와 릴레이션(유도)를 사용


## 기본 용어

스키마(Schema)

* 데이터베이스 스키마(database schema)는 데이터베이스에서 자료의 구조, 자료의 표현 방법, 자료 간의 관계를 형식 언어로 정의한 구조이다. 데이터베이스 관리 시스템(DBMS)이 주어진 설정에 따라 데이터베이스 스키마를 생성하며, 데이터베이스 사용자가 자료를 저장, 조회, 삭제, 변경할 때 DBMS는 자신이 생성한 데이터베이스 스키마를 참조하여 명령을 수행한다.

* 스키마는 3층 구조로 되어있다.

    + 외부 스키마(External Schema) : 프로그래머나 사용자의 입장에서 데이터베이스의 모습으로 조직의 일부분을 정의한 것
    + 개념 스키마(Conceptual Schema) : 모든 응용 시스템과 사용자들이 필요로하는 데이터를 통합한 조직 전체의 데이터베이스 구조를 논리적으로 정의한 것
    + 내부 스키마(Internal Schema) : 전체 데이터베이스의 물리적 저장 형태를 기술하는 것

SQL쿼리(SQL Query)
* 관계형 DBMS를 사용하는 전용 질의언어
* 대소문자를 가지리 않음(Interpreter Langague)

기본키(Primary Key) - PK
* 기본 키(primary key)는 주 키 또는 프라이머리 키라고 하며, 관계형 데이터베이스에서 조(레코드)의 식별자로 이용하기에 가장 적합한 것을 관계 (테이블)마다 단 한 설계자에 의해 선택, 정의된 후보 키를 말한다. 유일 키는 0~1개 이상의 속성의 집합으로 볼 수 있다
* 관계형 데이터베이스 관리 시스템(RDBMS)과 미들웨어, 애플리케이션 등의 레코드 식별자가 필요한 경우 기본 키가 사용된다. 반드시 기본 키를 사용해야만 하는 경우가 아니면, 다른 후보 키로 대체되어도 기능 수행에는 문제가 없다. 따라서 기본 키의 이론적 의의는 크지 않지만 실무에서 널리 사용되고 있는 개념이다. 그러나 기본 키는 NULL의 존재가 허용되지 않지만, 후보 키에 허용이 되는 차이가 있다. (레코드 추가, 업데이트할 때 제약 조건으로 기본 키를 생각한다면, 고유 제약 조건에 NOT NULL 제약을 가한 것이 기본 키 제약 조건이라고 생각할 수 있다). 관계에 있는 후보 키가 하나인 때에는 그 후보 키가 당연히 기본 키가 된다. 또한 기본 키가 아닌 후보 키는 대리 키(alternate key)라고 한다.
* 테이블에서 하나의 레코드를 지정할 수 있는 하나 이상의 컬럼집합
* 테이블에서 유일한 오직 하나의 값

외래키(Foreign Key) - FK
* 관계형 데이터베이스에서 외래 키(외부 키, Foreign Key)는 한 테이블의 필드(attribute) 중 다른 테이블의 행(row)을 식별할 수 있는 키를 말한다
* 어떤 테이블의 기본키가 다른 테이블의 컬럼에 들어가는 컬럼

테이블(Table)
* 관계형 데이터베이스와 플랫 파일 데이터베이스에서 테이블(table)은 세로줄과 가로줄의 모델을 이용하여 정렬된 데이터 집합(값)의 모임이다.
* 테이블 내의 데이터는 물리적으로 데이터베이스에 저장되지는 않는다. 뷰 또한 관계형 테이블이지만 이들의 데이터는 쿼리 시간에 계산된다. 다른 예로 별명(nickname)이 있는데 이는 다른 데이터베이스의 표를 가리키는 포인터를 나타낸다.
* 정보들의 묶음 단위

컬럼(Column)
* 컬럼(column)이란 관계형 데이터베이스 테이블에서 특정한 단순 자료형의 일련의 데이터값과 테이블에서의 각 열을 말한다. 컬럼은 열이 어떻게 구성되어야 할 지에 대한 구조를 제공한다.
* 관계형 데이터베이스 용어에서 컬럼과 같은 의미로 사용되는 것은 속성(attribute)이다.
* ‘필드’(field)라는 용어가 종종 컬럼의 대용으로 동일한 의미로 사용되지만, 필드와 필드값은 한 열이나 한 컬럼 사이의 교차로 존재하는 단일 항목을 특정할 때 언급하는 것이다.
* 테이블을 구성하는 여러개의 정보들

레코드(Record)
* 로우(row, 행)는 관계형 데이터베이스에서 레코드(record) 또는 튜플(tuple)로 불리기도 하며, 어떤 테이블에서 단일 구조 데이터 항목을 가리킨다. 간단한 용어로, 데이터베이스 테이블은 로우와 컬럼 또는 필드로 구성되어 있다고 간주할 수 있다.
* 각 테이블의 행은 일련의 관련 자료를 나타내며, 테이블에서 모든 로우는 동일한 구조를 가지고 있다.
* 테이블에 들어 있는 여러가지 인스턴스 하나하나를 지정
* 대학교의 학과 테이블
* 기본키(PK)로 구별가능

도메인값(Domain Value)
* 각 컬럼에서 나올 수 있는 후보값


## MySQL & Maria DB

기본 명령어

```SQL
show databases;     // DB들의 리스트를 표시

use world;          // DB들의 리스트 중 'world'를 사용

show tables;        // 사용하는 'world'의 테이블 리스트를 표시

desc city;          // 'city' 테이블의 구조를 표시

select * from city  // 'city' 테이블의 내용을 표시
```

## SQL

>SQL (Structured Query Langague)

* 데이터베이스에 있는 필요한 정보를 사용할 수 있도록 도와주는 언어
* 인터프리터(쿼리문을 입력 받아야 실행)
* 대소문자를 구별하지 않는다(데이터 내용은 구별함)

### DML

> DML(Data Manipulation Langague)

* 테이블의 데이터를 조작하는 기능
* 테이블의 레코드를 CRUD(생성, 삭제, 수정, 조회)
    + INSERT
    + DELETE
    + UPDATE
    + SELECT
### DDL

> DDL(Data Definition Langugae)

* 데이터베이스 테이블의 스키마를 정의, 수정하는 기능
* 데이터베이스 테이블의 생성, 컬럼추가, 타입변경, 각종 제약조건 지정, 수정
    + CREATE
    + DROP
    + ALTER

### DCL

> DCL(Data Control Langague)

* 데이터 베이스나 테이블의 접근 권한이나 CRUD 권한을 정의하는 기능
* 특정 사용자에게 테이블의 조회권한 허가/금지 등
    + GRANT
    + REVOKE


## DISTINCT

SELECT문의 결과값에서 특정 컬럼만 출력할 경우 중복된 값들이 나오는 경우 이를 제거해서 표시하는 기능

> SELECT DISTINCT 컬럼명..... FROM 테이블명

## 논리연산자(AND, OR, NOT, IN, BETWEEN)

SELECT문의 조건절에 논리 조건을 적용해서 원하는 값을 조회할 수 있는 기능

## 결과값 정렬(ORDER BY)

오름차순 or 내림차순으로 결과값을 정렬하여 조회
**여려 개의 경우 컬럼 나열된 순서로 적용(1차정렬, 2차정렬...)**


## 결과값 일부 조회

> 대표적인 비 표준 기능(DBMS 종류마다 다름)
> LIMIT(ROWNUM, TOP)

* SQL쿼리 결과 중 상위 몇 개만 보여주는 쿼리
* 대표적인 비표준기능()

## 집합함수

COUNT()
MIN()
MAX()
SUM()
AVG()

# SQL METHODS

```SQL
LENGTH()                // 레코드의 문자열 컬럼의 글자수를 리턴
MID(a, b)               // a자리부터, b자리까지 문자열을 잘라서 리턴
UPPER()                 // 레코드의 문자열을 모두 대문자로 리턴
LOWER()                 // 레코드의 문자열을 모두 소문자로 리턴
ROUND(컬럼, 자리수)     // 레코드의 소수값을 반올림 해주는 함수
```

!25분 강의-JOIN 다시보기

## JOIN

* 서로 다른 테이블의 공통 컬럼을 기준으로 합치는(결합하는) 테이블 단위 연산
* 조인의 결과 테이블은 이전 테이블의 컬럼 수의 합과 같다.
* 조인시 서로 다른 테이블에 같은 컬럼명이 존재하면 구분을 위해 테이블명.컬럼명으로 사용해서 표
> 문법
> SELECT * FROM table1 JOIN table2 on table1.column = table2.column
* 조인시 NULL 값을 허용하는 내부조인(불과)과 외부조인(허용)으로 구분
  + INNER JOIN
  + LEFT JOIN
  + RIGHT JOIN
  + FULL JOIN(UNION)


## VIEW

* SQL쿼리의 결과값을 임시테이블로 저장해서 사용할 수 있다.
* 사용용도가 끝나면 명시적으로 삭제해야 한다.(DROP VIEW...)
> 문법
> CREATE VIEW name AS SELECT .....


## SELECT INTO

* 쿼리 결과를 새 테이블로 만든다.
* 기존에는 존재하지 않는 테이블이 새로 생성된다.
> 문법
> CREATE TABLE table-name1 SELECT * FROM table-name2 WHERE ...

## INSERT INTO SELECT

* 쿼리 결과를 기존 테이블에 추가한다.(기존 테이블이 존재 해야 한다.)
* SELECT 하는 테이블과 INSERT 테이블은 동일한 구조를 가져야 한다.
* 두 개의 별도 쿼리를 하나로 합친다.
> 문법
> INSERT INTO table-name1 SELECT * FROM table-name2 WHERE ...

## CASE ~ WHEN ~ END

* SQL의 조건문(IF/SWITCH) 해당

## LIKE 검색

* 정확한 키워드를 모를 경우 일부만으로 검색하는 방법
* 와일드카드(%, ____)를 사용하여 패턴매칭___
      + % : 0 - n 글자
      + _ : 1 글자
* LIKE 검색은 매칭하기 위해 DBMS에 부담이 많으므로 LIKE에 OR 같은 논리조건자를 중복해서 사용하지 않는게 좋음
> 문법
> SELECT * FROM table-name WHERE LIKE column-name%_

## NULL VALUE

* NULL 이란 해당 컬럼의 값이 없다는 의미(해당 컬럼이 NULL값을 허용하는 경우)
* NULL 값을 가지고 있는 컬럼을 검색하려면 > IS NULL의
* NULL 이 아닌 값을 가지고 있는 컬럼을 검색하는 경우
> 문법
> IS NULL / IS NOT NULL

## NULL 함수

* 숫자컬럼을 연산해야 할 때 NULL 을 처리해주는 함수
* NULL 값이 나오면(주로 0)으로 대체해서 계싼에 문제없도록 처리
* 숫자연산/집합함수(Ex: SUM())의 경우 내장처리 되있어서 NULL함수를 사용하지 않아도 된다.
* 직접 함수나 쿼리에 넣는 경우는 NULL 함수를 사용해야 함.
> 문법
> ISNULL()
> COALESCE()

## GROUP BY / HAVING

* 집합함수와 같이 사용해 그룹별 연산을 적용한다.
> 문법
> SELECT column-name, 집합함수명(column-name) FROM table-name GROUP BY group-column-name;

### HAVING

* 그룹별 연산을 할때, 집합연산에 WHERE 조건절 대체 조건연산


## 서브쿼리(SubQuery)

* 쿼리문 내에 또다른 쿼리문이 있는 형태
* 서브쿼리는 메인쿼리에 포함되는 관계
    + 괄호() 를 사용해 감싸는 형태
    + ORDER BY 를 사용하지 못한다.
* 3가지 종류
    + 단일행 서브쿼리
        - 결과가 레코드 하나인 서브쿼리
        - 일반 연산자(=, >, <, ...) 사용
    + 다중행 서브쿼리
        - 결과가 여러개 레코드인 서브쿼리
        - [다중 행 연산자(IN, ALL, ANY, IN/EXISTS)](#다중-행-연산자)

    + 다중컬럼 서브쿼리
        - 결과가 여러개의 컬럼을 구성하는 쿼리


### 다중 행 연산자

#### ALL

* 여러 개의 레코드의 AND 효과 (가장 큰 값보다 큰)
* Population > ALL (SELECT Population ....)

#### ANY

* 여러 개의 레코드의 OR 효과 (가장 작은 값보다 큰)
* Populatiokn > ANY (SELECT Population ....)

#### IN/EXISTS

* 결과 값 중에 있는 것 중에서의 의미
* IN : 전체 레코드를 스캔
* EXISTS : 존재 여부만 확인하고 스캔하지 않음(상대적으로 IN보다 빠르다)
    + 결과값 리턴을 TRUE or FALSE


## 집합연산

* 각종 집합연산 지원(3가지)
    + 합집합(UNION)
    + 교집합(INTERSECT)
    + 차집합(MINUS)
* **MySQL은 교집합, 합집합을 지원 하지 않음**

### UNION

* 두 쿼리의 결과 형식이 동일해야 함(기본적으로 DISTINCT 적용)
* 다른 테이블이라도 결과값의 형식만 일치하면 됨

> 문법
> SELECT 쿼리1 UNION SELECT 쿼리2



# DDL (Data Definition Language)

* 데이터베이스와 테이블을 CRUD
* 테이블에 대한 정보는 메타데이터(Metadata)로 데이터사전(Data Dictionary)에 저장, 관리 된다.


## 데이터베이스 생성

> 문법
> CREATE DATABASE database-name

확인

> SHOW database-name

## 테이블 생성

> 문법
> CREATE TABLE table-name

## 데이터 자료형

### 정수형(부호있음/부호없음)
* TINYINT
* INT
* BIGINT

### 실수형(길이, 소수점 이하 자리수)
* FLOAT(size, d)
* DOUBLE(size, d)
* DECIMAL(size, d)

### 문자열
* CHAR (고정길이 문자열)
* VARCHAR (가변길이 문자열)

### TEXT 문자열
* TEXT(2Byte)
* MEDIUMTEXT(3Byte)
* LONGTEXT(4Byte)

### BLOL(Binary Large Object) - 이미지 or 동영상 등등 바이너리 데이터
* BLOL(2Byte)
* MEDIUMBLOL(3Byte)
* LARGEBLOL(4Byte)

### 시간
* DATE(YYYY-MM-DD)
* TIME(HH:MI:SS)
* DATETIME(DATA + TIME -> YYYY-MM-DD HH:MI:SS)
* TIMESTAMP(YYYY-MM-DD HH:MI:SS) - **1970-01-01 00:00:00 이후 걸린 시간(Unix Epoch) 계산**

## 제약조건

제약조건(Constraint): 입력 데이터의 제약조건을 걸어 해당되지 않는 데이터는 입력되지 않음

* NOT NULL : 데이터가 NULL 값을 받아들이지 않음
* UNIQUE : 테이블에 동일한 값이 입력되어 있을 경우 받아들이지 않음
* PRIMARY KEY : 기본키 제약조건(NOT NULL + UNIQUE)
* FOREIGN KEY : 외래키 제약조건
* CHECK : 입력값 체크(EX: Age >= 0) **MySQL 에서는 동작하지 않음**
* DEFAULT : 컬럼값이 입력되지 않으면 기본값을 입력

## 중복정보 제거

* 테이블 간의 정보는 중복되지 않아야 함
    + 동일한 정보가 여러 군데 테이블에 저장되어 있으면, 수정에 대한 부담과 무결성 유지가 쉽지 않다.
    + 하나의 정보는 한 군데만 나오도록 한다.
* 이를 위해 정규화(Normaliztion)를 통해 중복성 제거(제 1 ~ 6 정규형)
* 중복성 제거 후 필요한 정보는 외래키를 통한 조인을 통해 필요한 정보를 구한다.

### 정규형

중복을 제거하기 위한 테이블 정의 규칙

* 제 1정규형: 나룰 수 있을 만큼 분리.
* 제 2정규형: 테이블의 컬럼들이 기본키와 직접 연관되는 컬럼으로만 구성.
* 제 3정규형: 컬럼들 간의 종속관계가 없어야 한다.

## 참조무결성(Referential Integrity)

외래키(FK)에 적용되는 규칙

* 외래키와 참조되는 원래 테이블의 키와 관계를 명시
* **외래키를 참조하면 원래 테이블에 해당 레코드 값이 반드시 존재해야 한다.**
* **만약 원래 레코드를 삭제하려면, 참조하는 외래키(FK)값을 먼저 NULL로 or 다른 값으로 치환을 하여, 참조 무결성 조건을 만족 시켜야 한다.**
* 외래키 참조관계가 있을 경우에 레코드 추가.삭제시 선후관계를 나타낸다.

## 스키마 수정

### 수정
* 테이블 컬럼 추가/삭제
* 테이블 컬럼명 변겅, 컬럼 타입 변경
* 각종 제약조건 추가/삭제
* 테이블명 변경
* PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, DEFAULT

### 삭제
* DELETE : 레코드 삭제 - 스키마 유지
* TRUNCATE : 테이블 스키마는 유지, 전체 내용 삭제
* DROP : 테이블 전체 삭제, 스키마 삭제

## DCL

* 테이블의 권한 설정
    + 사용자 추가/삭제
    + 테이블 CRUD 권한 설정(로컬/랜/원격접속)
* 역활설정
    + 역활 추가/삭제
    + 역활별 CRUD 권한 설정
    + 사용자 역할 부여/삭제
* 원격접속 설정
    + 외부 인터넷에서 원격접속 설정

# INDEX

검색을 빠르게 하기 위한 자료구조(주로 B트리구조)

* 레코드 추가/수정/삭제 시 해당 컬럼으로 다시 정렬한 후 검색에 필요한 값들을 미리 계산해 검색 속도를 높임(trade off)
  - 상대적으로 추가/삭제의 속도가 느려진다.
  - 검색보다 추가/삭제가 빨라야 하는 상황에서는 인덱스가 없는것이 더욱 효율적이다.
* 기본키는 자동으로 인덱스 설정
* 인덱스 On/Off를 통해 검색속도 차이 체감(대량의 데이터일수록 큰 영향)
* 조인(Join)에도 영향을 준다.

## METADATA

데이터를 위한 데이터

* DB, 테이블의 스키마에 대한 정보를 저장하는 테이블
* DB명, 테이블명, 컬럼명, 스키마명

### METADATA 개념

#### 데이터사전(Data Dictionary)
* 데이터베이스의 정보 저장
* 시스템 카탈로그 라고도 함
* 일반적으로 읽기전용정보(Read-Only)

#### 데이터디렉토리(Data Directory)
* DBMS의 모든 데이터가 저장되는 데이터디렉토리(폴더)
* DB저장, 상태 및 로그 저


## CharacterSet / Collation

CharacterSet

* 문자인코딩 정보/메타데이터의 일종
* 문자열의 값을 저장할 때 사용되는 기조본 정보
* **DB/ 테이블 별로 별로 설정 가능**

Collation
* 데이터를 정렬(문자간의 비교)할 떄 사용하는 정보
* 정렬 시에 대소문자를 구분/비구분 여부 설정 가능(Case Sensitive/Insensitive)
* 한글 데이터의 경우 무의미

> Default Setting
> UTF8-GENERAL-CI(Case Insensitive 줄임말로 대소문자 비구문 명시)
>> 수정
>> UTF-8-UNICODE(CI가 없는 경우는 Case Sensitive로 대소문자 구문)

## Storage Engine

* 데이터베이스엔진
* DBMS가 데이터를 CRUD할 때 사용하는 기본 컴포넌트
* 대표적으로 MyISAM과 InnoDB등이 있다.(InnoDB)
* 데이터 접근속도/안정성/트랜젝션의 지원 여부등의 차이가 있음
* 기본값은 InnoDB

```
InnoDB : 트랜잭션 지원/업데이트 위주/줄 단위 락/복구용이/동시처리성능 높음
MyISAM : 상대적으로 높은 성능/읽기 위주/데이블 단위 락
```
---

# 파티셔닝/샤딩
 데이터베아스 파티셔닝(Partitioning)

## VLDB(Very Large DBMS)

* 전체 DB가 하나이 DBMS시스템에 다 들어가기 힘들어지는 경우
    + 테이블 들을 여러 개의 군으로 나눠 분산 저장
    + 하나의 테이블이 방대한 경우에는 사전방식(a-m, n-r, s-z)와 같이 나눠서 저장

## 파티셔닝(Partitioning)
DB 시스템에서 분할하는 시스템으로 DBMS에서 알아서 분할을 해주기 떄문에 분활 및 합치기가 비교적 쉽다.

* DBMS 레벨 분할
* 제약사항
    - 테이블 단위 연산이 힘들어짐(비용문제)
    - 조인연산 여려움 -> 정규화(Nomalization) 문제
    - 역정규화(Denomalization) -> 중복 허용으로 해결 -> 조인의 필요성을 줄임
* 외래키의 호용문제
    - 레코드 추가시 참조무결성 조건 체크 -> 시스템 부담증가로 수동전환
    - CRUD시 위치를 인식해야 함(파티셔닝/샤딩이 다름)
* 파티셔닝의 이점
    + 데이터 전체 검색시 필요한 부분만 탐색해 성능 증가
    + 전체 데이터를 손실할 가능성이 줄어듬 -> 가용성(Availability) 향상
    + 파티션별 백업/ 복구 가능
    + 파티션 단위로 I/O 분산가능 -> 업데이트 성능 증가
* 파티셔닝 방식
    + 범위(Range) : a-m / n-r / s-z
        - 분할한 시스템의 사이즈가 다르다. 편차가 클 수 있다.
    + 해시(Hash) : 해시함수 파티션별로 크기를 비슷하게 나눔
    + 리스트(List) : 특정한 컬럼을 기준
    + 컴포지트(Composite) : Range + Hash / Range + List


## 샤딩(Sharding)
DB 시스템에서 분할하는 것이 아닌 외부적인 요소로 분할 하기 떄문에 DB 시스템에서 분할을 추적하기가 쉽지않아 합치거나 참조하기가 굉장히 어려울 수 있다.

* DBMS 외부에서 분할/응용 레벨에서 구별해야 함


## Full Text Search
전문검색(Fill Text Search)

* 기존 SQL의 LIKE 검색은 여러 개의 검색필터를 동시에 매칭시키는 방식
* 여러 개의 조건문을 AND/OR 시킬 경우 심각한 성능 저하
* 하지만 네이버/다음 포탈 통합 검색
    + 통합 검색은 카페, 블로그, 이미지, 지도, 뉴스, 쇼핑 등 모든 카테고리 검색
    + 전부 Like 검색을 해야 하여 DB서버에 큰 부담을 준다.
* 결과는 동일하지만, DB서버에 부담을 주지 않는 방법 - 전문검색

### 전문검색(Fill Text Search)

* 기본적으로 컬럼 내용 전체를 단순 문자열로 생각하고 검색하는 방식
* 문자편집기의 편집 찾기/바꾸기 메뉴의 동작방식과 유사

### 전문검색 방식
1. 자연어 검색
2. 불린 검색
3. 쿼리 확장 검색

### Full Text Search 인덱스 생성

* Like 검색은 인덱스를 타지 않는다.
* Full Text Search를 할때, 인덱스틑 탈 수 있게 인덱스를 생성 해야 한다.


## BULK INSERT

* 대량의 데이터를 입력해야 할 경우 파일의 내용을 읽어 레코드를 삽입
* 인덱스 잡업을 정지시켜야 함 -> DB서버의 부하를 덜어 줄수 있음
